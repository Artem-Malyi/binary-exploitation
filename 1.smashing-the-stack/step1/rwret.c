//
// rwret.c
//
// Step 1: rewrite the function return address
//

#include <stdio.h>

//
// rewrite_return_address()
//
// This is an example of altering the return address from within the function
// written in C. It starts calculation from the bottom of the function stack,
// adding to it the sizes of the local buffers with stack padding considered.
// Then it increases the return address value just so that it will point to
// the cpu instructions right after x = 1; line in main(). In this way the
// x = 1; line will be skipped and "x: 0" will be printed to the console.


// The stack layout of the function at the moment it is entered follows below.
// The amount of spaces reflects the actual amount of bytes. Dots in buffers
// are the data bytes, and spaces are the stack padding placed by the compiler.
//     ret - address to which the processor will transfer its execution after
//           leaving the function
//     sfp - Stored Frame Pointer or EBP of the previous function main()
//
// bottom of                                                            top of
// memory                                                               memory
//            buffer2       buffer1   sfp   ret   a     b     c
// <------   [..........  ][.....   ][    ][    ][    ][    ][    ]
//           ^                       ^
//          esp                     ebp
// top of                                                            bottom of
// stack                                                                 stack


// If we want to skip x=1 line, we will also skip the "add 0x14, esp" instruction,
// which must clean up the stack used by the callee cdecl function. But with
// stdcall calling convention, compiler will generate the code that cleans the
// stack inside the called function.
__attribute__((stdcall))
void rewrite_return_address(int a, int b, int c) {
    // The buffer must be aligned by 2-byte boundary, in order to start buffer2
    // data exactly at the bottom of the function stack. Otherwise, the compiler 
    // may place the first byte of data at ebp-0x13 for example, and our 
    // buffer2-related calculation below will compute the wrong location of the 
    // return address.
    // Like in this case, note the dots:
    //
    // bottom of                                                            top of
    // memory                                                               memory
    //            buffer2       buffer1   sfp   ret   a     b     c
    // <------   [ .......... ][   .....][    ][    ][    ][    ][    ]
    //           ^                       ^
    //          esp                     ebp
    // top of                                                            bottom of
    // stack                                                                 stack
    //
    // Of course, I could access ebp value directly from the function code, but the
    // point is to get a good understanding of how the compiler may lay out data
    // buffers in stack.
    __attribute__((aligned(2))) char buffer1[5];  // actual size in stack: 8 bytes
    __attribute__((aligned(2))) char buffer2[10]; // actual size in stack: 12 bytes

    // 20 bytes for all the local buffers and 4 bytes for sfp (caller's ebp)
    int* ret = (int*)(buffer2 + 20 + 4);

    // 7 bytes is the size of x = 1 machine instructions that was obtained
    // during debug session.
    (*ret) += 7;
}

void main() {
    int x = 0;
    rewrite_return_address(1, 2, 3); // this function will alter its return address
    x = 1; // this line will be skipped during execution
    printf("x: %d\n", x); // this line will be executed after returning from the callee
}
